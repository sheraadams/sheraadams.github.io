# Data Structures and Algorithms

**Course Outcome 3**	Design and evaluate computing solutions that solve a given problem using algorithmic principles and computer science practices and standards appropriate to its solution, while managing the trade-offs involved in design choices (data structures and algorithms).

Completing CS300, Data Structures and Algorithms, was a significant milestone for me as I learned about the importance of choosing efficient data structures to improve performance, readability, and scalability in software. In CS300, we were asked to create a C++ course tracker application that loads courses from a text file, orders them alphabetically, prints a current course list, and allows for insertion and deletion into the course list. If this project were to scale enough, simple insertions and deletions could eventually exhaust the system's resources. To address the need for efficiency as the project scales, an appropriate data structure was required. To aid in the selection of an appropriate algorithm, I performed an algorithm analysis analyzing the line-by-line cost of the insertion function for Hash Table, Vector, and Binary Search Tree structures. While the Binary Search Tree was comparable but not the technically most efficient choice of the three structures compared, other factors also influenced my decision. I opted against the vector as the vector is more expensive in terms of memory allocation and they require sorting after each modification.  Similarly, I opted against the hash table as they can degrade as data grows and undergoes many collisions. 

In the end, I chose the Binary Search Tree for the application as it is extremely efficient and yields fast search results. Binary Search Trees are also great when growth and modification in the future are expected. Because of the specific functional requirements of the client, the Binary Search Tree was an appropriate choice, however, it requires storage for the tree itself and maintenance and it may not be the most practical solution for all applications. The Binary Search Tree example provides an example of some of the trade-offs involved in computer science that I learned to consider. Throughout my studies, I managed the inherent trade-offs associated with various design choices, considering at each new project if it would be worth the sacrifice of simplicity for a technically more efficient structure.  When considering an appropriate algorithm, there many factors to consider in this scenario including the projectâ€™s intended use, compatibility considerations, scale, cost, and resources. 

- **In the completion of the Binary Search Tree course tracker application for CS300, I demonstrated skills in algorithm analysis, C++, documentation, and communication.** You can find a sample of the pseudocode for this C++ binary search tree [course tracker application here](https://sheraadams.github.io/CS300).

- Also, see my data structures and algorithms enhancements for a [Java slideshow for a travel site here](https://sheraadams.github.io/#data-structures-and-algorithms).
